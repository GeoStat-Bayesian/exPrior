## regionalized ##

#'regionalized prior from multiple types of site-specific data
#'
#'\code{regionalized} generates a regionalized prior
#'from site-specific data from multiple sites
#'and of multiple types
#'
#'@param data a dataframe containing data to assimilate,
#' with fields dat, site_id and type (see example)
#'@param eval_theta a vector of numerical values of informative prior evaluation points
#'@param niter an integer for the number of samples to use in the MCMC
#'@param hierarchicalSigma a boolean specifying whether the site-specific variance
#'is defined hierarchically by an inverse-gamma distribution (T) or by a prior (F)
#'@param verbose boolean indicating whether R should print information from the progress
#'@return the pdf at values corresponding to theta
#'@examples
#' theta_vect <- seq(from=-10,to=10,by=0.1)
#' data_site_A <- data.frame(dat=c(2,4),
#'                           site_id=rep('A',2),
#'                           type=c('bound.min','bound.max'))
#' data_site_B <- data.frame(dat=c(2,0.1),
#'                           site_id=rep('B',2),
#'                           type=c('moment.1','moment.2'))
#' data_site_C <- data.frame(dat=c(2,3,4),
#'                           site_id=rep('C',3),
#'                           type=c('meas','meas','meas'))
#' df_data <- rbind(data_site_A,data_site_B,data_site_C)
#' rPrior::regionalized(data=df_data,eval_theta=theta_vect)
#'@export
regionalized <- function(data,
                         eval_theta,
                         niter=10^5,
                         hierarchicalSigma=F,
                         verbose=F){

  ##################################
  ## sanity checks for data types ##
  ##################################

  ## check that data types specified are valid

  TYPES <-c("meas",
            "moment.1","moment.2",
            "bound.min","bound.max")

  i.type <- pmatch(x = as.character(data$type),
                   table = TYPES,
                   duplicates.ok = T)

  if(any(is.na(i.type))){
    stop("invalid data type ",paste(data$type[which(is.na(i.type))]))
  }

  ## check that only one type of specification by site

  # calculate characters in type preceding the dots
  data$type <- as.character(data$type)
  data$type_start <- unlist(lapply(
    X = strsplit(x = data$type,split = '[.]'),
    FUN = function(x){x[1]}))

  unique_site_id <- as.character(unique(data$site_id))

  for(i in 1:length(unique_site_id)){

    # get subset of dataset corresponding to that site
    data_i <- subset(data,site_id == unique_site_id[i])

    if(length(unique(data_i$type_start))>1){
      stop("multiple data types for site ",unique_site_id[i],
           " : ",unique(data_i$type_start))
    }

    # raise error if moment.2 provided without moment.1
    if(("moment.2" %in% data_i$type) && !("moment.1" %in% data_i$type)){
      stop("moment.2 provided without moment.1 at site ",unique_site_id[i])
    }

  }


  ##################################
  ## change various types to meas ##
  ##################################

  # number of measurements generated by site
  # when moments or bounds are provided
  nbMeas=50

  df_meas <- data.frame(val=rep(0,0),site_id=rep('',0))

  for(i in 1:length(unique_site_id)){

    # get subset of dataset corresponding to that site
    data_i <- subset(data,site_id == unique_site_id[i])

    # check type of data provided for that site
    if(data_i$type_start[1]=="meas"){

      df_meas_i <- data.frame(val=data_i$dat,
                              site_id=data_i$site_id)

      # if datatype is bounds
    }else if(data_i$type_start[1]=="bound"){

      # define minimum bound
      if('bound.min' %in% data_i$type){ # if minimum bound is provided
        b_min <- as.numeric(
          data_i[which(data_i$type == "bound.min"),
                 'dat'])
      }else{ # if minimum bound is not provided
        # check from other sites if possible
        data_subset <- subset(data,
                              type_start %in% c("meas","bound") &
                                site_id != data_i$site_id[1])
        if(nrow(data_subset)!=0){ # if values are provided, fix to minimum of values
          b_min <- min(data_subset$dat)
        }else{ # else fix to minimum bound of theta vector
          b_min <- min(eval_theta)
        }
      }

      # define maximum bound
      if('bound.max' %in% data_i$type){
        b_max <- as.numeric(
          data_i[which(data_i$type == "bound.max"),
                 'dat'])
      }else{ # if maximum bound is not provided
        # check from other sites if possible
        data_subset <- subset(data,
                              type_start %in% c("meas","bound") &
                                site_id != data_i$site_id[1])
        if(nrow(data_subset)!=0){ # if values are provided, fix to minimum of values
          b_max <- max(data_subset$dat)
        }else{ # else fix to minimum bound of theta vector
          b_max <- max(eval_theta)
        }
      }
      # define measurement dataframe in case of bounds
      df_meas_i <-
        data.frame(val=qunif(p = (1:nbMeas)/(nbMeas+1),
                             min = b_min,
                             max = b_max),
                   site_id=rep(data_i$site_id[1],nbMeas))


      # if data type is moments
    }else if(data_i$type_start[1]=="moment"){

      # if variance is present, then sample from normal
      if("moment.2" %in% data_i$type){
        val_vect <- qnorm(p = (1:nbMeas)/(nbMeas+1),
                          mean = as.numeric(data_i[which(data_i$type=='moment.1'),
                                                   'dat']),
                          sd = sqrt(as.numeric(data_i[which(data_i$type=="moment.2"),
                                                      'dat'])))
      }else if ("moment.1" %in% data_i$type){ # get density from me_densFromSamples

        pdf_me <-
          exPrior:::me_densFromMoments(
            mu = as.numeric(data_i[which(data_i$type=='moment.1'),
                                   'dat']),
            x = seq(min(eval_theta),max(eval_theta),length=1000))

        # calculate corresponding cumulative distribution
        cdf_me <- cumsum(pdf_me$pEval[,1])
        # normalize cdf
        cdf_me <- cdf_me / cdf_me[length(cdf_me)]

        # look into cdf to find antecedents from quantiles
        plot(x = pdf_me$xEval,y = cdf_me)
        val_vect <- approx(x = cdf_me,y=pdf_me$xEval,
                           xout=(1:nbMeas)/(nbMeas+1))

      }else{stop("sampling from moments didn't work for site ",unique_site_id[i])}

      df_meas_i <- data.frame(val=val_vect,
                              site_id=rep(data_i$site_id[1],nbMeas))

    }

    # append to main measurement dataframe
    df_meas <- rbind(df_meas,df_meas_i)

  }

  # force val field to numerics
  df_meas$val <- as.numeric(df_meas$val)

  ################
  ## final call ##
  ################

  return(exPrior::genExPrior(meas = df_meas,
                             eval_theta = eval_theta,
                             niter=niter,
                             hierarchicalSigma = hierarchicalSigma,
                             verbose=verbose))

}
